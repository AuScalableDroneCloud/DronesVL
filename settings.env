####################################################################################################
# OpenDroneMap on k8s for ASDC DronesVL
# Owen Kaluza, Monash University, August 2020
#
# Settings and setup script - use "source settings.env" to apply
#
# - This script also sets up access to openstack and the kubernetes cluster - required to use kubectl
# - Needs openstack nectar credentials (set with RC_FILE or source before running)
####################################################################################################
set -a #Exports all variables

#Use our config file from openstack magnum for kubectl
export KUBECONFIG=$(pwd)/secrets/kubeconfig

#Hostname where app will run
WEBAPP_HOST=asdc.cloud.edu.au
WEBAPP_IP=118.138.248.159
JHUB_LOADBALANCER_IP=118.138.248.98
METASHAPE_IP=118.138.248.128
#TUSD_HOST=tusd.asdc.cloud.edu.au
#TUSD_IP=118.138.249.194

#Volume IDs - store these now, for asdc_update.sh
export WEB_VOLUME_ID=eef77616-73b7-44d2-99f5-4b48a33a83ad
export DB_VOLUME_ID=9ee0ead5-903c-466b-a51b-fe87986df30b

#Set cluster name
CLUSTER=asdc-k8s
#Create a cluster template of this name
TEMPLATE=${CLUSTER}-template
KUBE_TAG=v1.21.1
FLANNEL_TAG=v0.14.0-amd64

#Number of nodes in cluster
MASTER_NODES=3
APP_NODES=2
NODES=6
NODES_P4=0
NODES_A40=2
NODES_A100=4
DOCKER_VOL_SIZE=50
CLUSTER_DOCKER_VOL_SIZE=100

#Deployment of images on cluster nodes
NODE_ODM=4
NODE_ODM_GPU=4 #Number of NodeODM nodes that will request GPU
#NODE_ODM_GPU=0 #GPU DISABLED
NODE_MICMAC=0
NODE_METASHAPE=0

#NodeODM command line args for GPU and CPU nodes
#https://community.opendronemap.org/t/enabling-split-merge-on-webodm/4378/9
#eg: --max-images: Max images per node, based on available RAM
#    --max-concurrency: Max threads per node, based on CPU cores
#ODM_FLAGS_GPU='["--max-images", "1000", "--max-concurrency", "22"]'
ODM_FLAGS_GPU=''
ODM_FLAGS=''

#Image to use for nodes
#See: https://wiki.openstack.org/wiki/Magnum#Compatibility_Matrix and kube_tag label
IMAGE=fedora-coreos-32 #Requires flannel restart or has dns lookup failures
#This is the default keypair, needs to be the name of an existing keypair in openstack
KEYPAIR=ASDC_ODM
#Private key
KEYFILE=secrets/${KEYPAIR}.pem
#Availability zone
ZONE=monash-02
#External network
NETWORK=monash
#Flavour for the master node used for kubernetes
MASTER_FLAVOUR=m3.small
#Flavours for the minions - this is where the actual pods are deployed
APP_FLAVOUR=m3.xlarge
CLUSTER_P4_FLAVOUR=mon.c22r60.gpu-p4   #60G RAM
#CLUSTER2_FLAVOUR=mon.c28r350d1000-gpu-t4 #350GB RAM
CLUSTER_A40_FLAVOUR=mon.c104r920.4gpu-A40.numa
#CLUSTER_A100_FLAVOUR=mon.c104r1840.4gpu-A100.numa #4xGPU,1840,104,3TB
#CLUSTER_A100_FLAVOUR=mon.c104r920.4gpu-A100.numa #4xGPU,960,104,3TB
#CLUSTER_A100_FLAVOUR=mon.c26r460.gpu-A100.numa #1xGPU,460,26,0.75TB
CLUSTER_A100_FLAVOUR=mon.c26r230.gpu-A100.numa #1xGPU,230,26,0.75TB
#Name prefix for creating clusters
CLUSTER_BASE=gpu

#Openstack rc file
RC_FILE=secrets/Monash-Drone-openrc.sh

#Secret env file - contains keys for auth0 etc
SECRET_FILE=secrets/secret.env

#Volume sizes for persistent storage in GB
# - Volume assigned to each NodeODM/ClusterODM processing nodes
NODE_VOLSIZE=1 #Minimal ephemeral volumes when using local scratch mounts
# - PostresSQL Database for the webapp
DB_VOLUME_SIZE=30
# - Working volume for the webapp
WEBAPP_VOLUME_SIZE=1000
# - Working volume for tusd uploads
TUSD_VOLUME_SIZE=300

# - Database volume for jupyterhub
JHUB_VOLUME_SIZE=1
# Host for jupyterhub
JHUB_HOST=jupyter.asdc.cloud.edu.au
JHUB_ADMIN_USER=

####################################################################################################
#DEV ENVIRONMENT? Set ASDC_DEVENV
if [ ! -z ${ASDC_DEV+x} ]; then 

  echo "****************************************************************************************"
  echo " ** USING DEVELOPMENT ENVIRONMENT SETTINGS **"
  echo "****************************************************************************************"
  source settings_dev.env
else
  echo "****************************************************************************************"
  echo " ** USING PRODUCTION ENVIRONMENT SETTINGS **"
  echo "****************************************************************************************"
fi
####################################################################################################

#Secrets
if [ -f $SECRET_FILE ];
then
  echo "Using $SECRET_FILE."
  source $SECRET_FILE
fi
#Auth0 key/secret
if [ -z ${WO_AUTH0_KEY+x} ] || [ -z ${WO_AUTH0_SECRET+x} ] || [ -z ${WO_AUTH0_DOMAIN+x} ];
then
  echo "Secret env file $SECRET_FILE does not exist or is missing values."
  echo "Please set key/secrets to use, see: secrets/secret.env.template"
fi

####################################################################################################

#Ensure ID set for openstack
if [ -z ${OS_PROJECT_ID+x} ];
then
  echo "OS_PROJECT_ID is unset";
  if [ -f $RC_FILE ]; then
    echo "Using $RC_FILE."
    source $RC_FILE
  else
    echo "Openstack rc file $RC_FILE does not exist."
    echo "Please source your openstack credentials"
    return 1
  fi
else
  echo "OS_PROJECT_ID is set to '$OS_PROJECT_ID'";
fi

# Generate the secret tokens for jupyterhub
if [ -z ${JHUB_SECRET_TOKEN+x} ];
then
  echo "Generating new JupyterHub secret token"
  JHUB_SECRET_TOKEN=$(openssl rand -hex 32)
  JHUB_CRYPT_KEEPER_KEY1=$(openssl rand -hex 32)
fi

# Generate the secret tokens for WebODM field encryption
if [ -z ${WO_ENCRYPTION_KEY+x} ];
then
  echo "Generating new WebODM secret token"
  WO_ENCRYPTION_KEY=$(openssl rand -hex 16)
fi

####################################################################################################

#If secrets/kubeconfig exists, use it for kubectl
if [ -s "secrets/kubeconfig" ] && grep "${CLUSTER}" secrets/kubeconfig;
then
  export KUBECONFIG=$(pwd)/secrets/kubeconfig
  echo "Set KUBECONFIG='$KUBECONFIG'";
fi

#Check for dependencies
if ! command -v kubectl &> /dev/null
then
  #Add cwd to path so local kubectl can be run without ./
  PATH=$PATH:$(pwd)
  if ! command -v kubectl &> /dev/null
  then
    echo "kubectl could not be found! run ./install.sh to install dependencies"
  fi
fi

if ! command -v helm &> /dev/null
then
  echo "helm could not be found! run ./install.sh to install dependencies"
fi

if ! command -v openstack &> /dev/null
then
  echo "openstack could not be found! run ./install.sh to install dependencies"
fi

if ! command -v flux &> /dev/null
then
  echo "flux could not be found! run ./install.sh to install dependencies"
fi
#Ensure flux version doesn't bounce around
FLUX_VERSION=0.31.1
FLUXVER=$(flux --version | cut -d " " -f 3)
if [ "${FLUX_VERSION}" != "${FLUXVER}" ];
then
  echo "FLUX VERSION MISMATCH: ${FLUXVER} != ${FLUX_VERSION}"
  sleep 5
  return 1
fi

#Utility functions for scripts
function subst_template()
{
  #Use envsubst to apply variables to template .yaml files
  #$1 = filename.yaml

  #Runs envsubst but skips vars not defined in env https://unix.stackexchange.com/a/492778/17168
  cat templates/$1 | envsubst "$(env | cut -d= -f1 | sed -e 's/^/$/')" > yaml/$1
  echo "Applied env to template: templates/$1 => yaml/$1"
}

function apply_template()
{
  #Substitute env vars
  subst_template $1
  #Apply to cluster
  kubectl apply -f yaml/$1
}

STATUS=''
function get_status()
{
  #Get the status of the running cluster
  STATUS=$(openstack coe cluster show $CLUSTER -f value -c status)
}

function cluster_check()
{
  #if [ "$STATUS" == $1 ]; then
  #Checks for desired status as sub-string,
  #eg: UPDATE_COMPLETE/CREATE_COMPLETE will match COMPLETE
  if [[ "$STATUS" == *"$1"* ]]; then
    return 0
  fi
  return 1
}

function cluster_launched()
{
  if cluster_check "COMPLETE" ; then
    return 0
  fi
  if cluster_check "CREATE_IN_PROGRESS"; then
    return 0
  fi
  return 1
}

function wait_for_pod()
{
  #Loop until pod is running
  #$1 = pod name
  until kubectl get pods --field-selector status.phase=Running | grep $1
  do
    echo "Waiting for pod to enter status=Running : $1"
    sleep 2
  done
  echo "Pod is running : $1"
}



